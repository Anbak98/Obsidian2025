## 객체 지향 언어


## C++
- Class/Struct는 기본 접근 제한자가 각각 Private/Public이다. 상속의 기본 접근 제한자도 동일하다. class는 추상화 목적으로 사용하고, struct는 데이터 구조를 정의할 때 사용한다. 필요에 따라 함수를 추가할 수도 있다.
- Inline-function은 컴파일 단계에서 in-place로 확장된다. 때문에 함수 호출 오버헤드가 제거되지만, 오브젝트 파일/실행 파일의 크기가 커진다.
- List container는 시퀸스/노드 기반
- rvalue(right-value)는 일반적으로 직접 참조하거나 주소를 구할 수 없는 값이다. 대게 메모리가 아닌, 계산 결과를 일시적으로 저장하는 레지스터나 스택에 위치한다.  리터럴 값/일시적으로 생성된 임시 객체/연산 결과등이 rvalue에 속한다.  
- lvalue reference int& x, rvalue reference int&& x
- rvalue reference는 C++11부터 도입돼 이동 시맨틱을 구현한다. 소유권을 이전하며, 이는 메모리 위치를 바꾸는 것이 아니라 해당 메모리의 자원을 관리하는 포인터나 참조를 새로운 객체로 이전한다는 의미다. 이동 후 원래 겍체는 빈 껍데기 상태로 남는다. std::move() 함수를 통해 lvalue를 rvalue로 바꾸고, rvalue reference로 전달 가능하다.
- Reference는 변수를 가리키는 별칭이다. 이를 사용하면 값에 직접 접근할 수 있다. 포인터와 유사하지만 주소 연산자를 사용하지 않고 초기화 후 변경될 수 없다는 차이점이 있다. 추가적으로 초기화가 필요하고 null을 가리킬 수 없다.

## C샵
- List<> 클래스는 내부적으로 동적 배열(dynamic array) 구조를 사용한다. C++의 vector와 마찬가지로 배열을 확장한다. 다만 .NET 스타일의 메서드를 제공하며, 메모리를 가비지 컬렉터가 관리한다는 점에서 다르다
- `게임오브젝트(GameObject)`는 일반적으로 **프로퍼티**라기보다는 **오브젝트**나 **인스턴스**로 불립니다.

- **프로퍼티(Property)**: C#에서 프로퍼티는 클래스나 객체의 상태를 노출하는 방식으로, 주로 특정 필드에 대한 접근자(`get`, `set`)를 통해 값을 가져오거나 설정하는 데 사용됩니다.
- **게임오브젝트(GameObject)**: 유니티에서 `GameObject`는 게임 씬에서 객체를 나타내는 기본 단위로, 컴포넌트를 통해 다양한 기능을 추가할 수 있는 실체입니다.

따라서 `GameObject`를 "프로퍼티"라고 부르는 것은 정확하지 않으며, 대신 "객체", "오브젝트", 또는 "게임 오브젝트"로 부르는 것이 더 적절합니다.

그러나 `GameObject`가 다른 클래스의 필드로 선언되어 있다면, 그 필드에 대한 **프로퍼티**(예: `public GameObject MyObject { get; set; }`)를 만들 수 있으며, 그 프로퍼티를 통해 `GameObject`에 접근하게 할 수는 있습니다.
# Memory
# Time/Space Complexity
# OS
 - 오브젝트 파일(.o/.obj)는 C++ 컴파일러가 소스 코드를 기계어로 변환한 중간 파일이다. 여러 소스 파일을 각각 오브젝트 파일로 컴파일한 후, 링크 단계에서 각 파일을 합쳐 하나의 실행 파일을 만든다.
- 실행 파일(.out)은 오브젝트 파일들을 링커가 합친 실행 가능한 프로그램이다. 

# 결의
언제든지 시작할 준비가 되어있따.
