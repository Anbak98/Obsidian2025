비const 참조에 대한 초기 값은 lvaue야 한다. > 변

RPC는 PlayerProfile 객체의 생성과는 관련이 없었다. OnPlayerJoined 함수로 객체 생성 코드를 옮기니까 그제서야 관련 에러가 발생. 그럼

c#과 c++에서 string 구조의 차이는

### 🔹 **1. 기본 자료형**

| 항목        | C#                            | C++                              |
| --------- | ----------------------------- | -------------------------------- |
| 기본 문자열 타입 | `string` (또는 `System.String`) | `std::string` (또는 C 스타일 `char*`) |
| 네임스페이스    | `System`                      | `std` (C++ 표준 라이브러리)             |
|           |                               |                                  |

---

### 🔹 **2. 메모리 관리**

- **C#**
    
    - `string`은 **immutable (불변)** 객체.
        
    - 한 번 생성된 문자열은 수정 불가능 → 새로운 문자열이 생성됨.
        
    - 가비지 컬렉션(GC)에 의해 메모리 관리됨.
        
    - 문자열 결합이 많을 경우, `StringBuilder` 사용 권장.
        
- **C++**
    
    - `std::string`은 **mutable (가변)** 객체.
        
    - 문자열 수정이 가능함 (예: `+=`, `insert`, `erase` 등).
        
    - 수동 메모리 관리 가능 (특히 C 스타일 `char*` 사용 시).
        
    - C++11 이후에는 move semantics 등 성능 최적화 도구도 많음.
        

---

### 🔹 **3. 성능**

- C#의 `string`은 불변이므로, 문자열 연산 시 **메모리 할당과 해제**가 자주 발생 → 성능 이슈 가능.
    
- C++의 `std::string`은 가변이라 문자열 연산이 더 효율적일 수 있음.
    
- 하지만 복사나 동적 할당 비용이 있으므로, C++에서도 상황에 따라 성능 고려 필요.
    

---

### 🔹 **4. 문자열 인코딩**

- **C#**:
    
    - 내부적으로 **UTF-16** 사용.
        
    - 국제화 지원이 좋음.
        
- **C++**:
    
    - `std::string`은 기본적으로 **ASCII 혹은 UTF-8 바이너리**.
        
    - 유니코드를 제대로 다루려면 `std::wstring`, `char16_t`, `char32_t` 등의 타입과 ICU 같은 외부 라이브러리 사용 필요.
        

---

### 🔹 **5. 문자열 비교 및 기능**

- **C#**
    
    - `==`, `.Equals()`, `.Compare()`, `.Contains()`, `.Replace()` 등 다양한 메서드 내장.
        
    - `string`은 레퍼런스 타입이지만 `==` 연산자는 내용 비교로 오버로드되어 있음.
        
- **C++**
    
    - `std::string`은 `==`, `!=`, `<`, `>` 연산자 오버로드되어 있음.
        
    - 멤버 함수로 `compare()`, `find()`, `substr()` 등 제공.